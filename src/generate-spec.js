/**
 * Copyright 2015 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var parse = require("./webidl-parser").parse;

var specSource = require('fs').readFileSync(__dirname + '/../node_modules/shift-spec-idl/spec.idl', 'utf-8');

var declarations = parse(specSource);

var database = Object.create(null);

var TYPE_INDICATOR_ENUM_NAME = "TYPE_INDICATOR";

// Although the specification does not define an order for an interface's attributes,
// this implementation orders the `fields` array of each interface by the order they
// may appear in the concrete syntax.
var tailNames = {
  Function: ['params', 'body'],
  MethodDefinition: ['body'],
  IterationStatement: ['body'],
  DoWhileStatement: ['test'],
  Class: ['super', 'elements'],
};

function renderType(t) {
  switch (t.type) {
    case "union":
      t = expandType(t);
      return "Union(" + t.ts.map(renderType).join(", ") + ")";
    case "array":
      return "List(" + renderType(t.t) + ")";
    case "ref":
      t = expandType(t);
      if (t.type === "ref") {
        return t.name;
      }
      return renderType(t);
    case "string":
      return "STRING";
    case "unsigned long":
    case "double":
      return "DOUBLE";
    case "boolean":
      return "BOOLEAN";
    case "nullable":
      return "Maybe(" + renderType(t.t) + ")";
    default:
      throw new Error("Not implemented");
  }
}

function expandType(t) {
  var tex = expandUnion(t);
  return tex.length === 1 ? tex[0] : {type: "union", ts: tex};
}

function expandUnion(t) {
  switch (t.type) {
    case "union":
      return [].concat.apply([], t.ts.map(expandUnion));
    case "ref":
      if (database["$" + t.name] && !database["$" + t.name].isInterface && typeof database["$" + t.name] !== "string") {
        return expandUnion(database["$" + t.name]);
      }
      return [t];
    case "array":
      return [{type: "array", t: expandType(t.t)}];
    case "nullable":
      return [{type: "nullable", t: expandType(t.t)}];
    default:
      return [t];
  }
}

// Step 1. know all the types
declarations.forEach(function (declaration) {

  function hasTailIndicator(member) {
    return tailNames[declaration.name] && tailNames[declaration.name].indexOf(member.member.name) >= 0;
  }

  function hasNoTailIndicator(member) {
    return !hasTailIndicator(member);
  }

  switch (declaration.type) {
    case "typedef":
      database["$" + declaration.name] = declaration.t;
      break;
    case "enum":
      database["$" + declaration.name] = "ENUM";
      break;
    case "interface":
      database["$" + declaration.name] = {
        isInterface: true,
        parents: [],
        tail_parents: [],
        members: declaration.members.filter(hasNoTailIndicator),
        tail_members: declaration.members.filter(hasTailIndicator),
      };
      break;
  }
});

var notFinal = {};

function has(member, name) {
  if (member.ea.length != 0) {
    for (var i = 0; i < member.ea.length; i++) {
      if (member.ea[i].name === name) {
        return true;
      }
    }
  }
  return false;
}

function inherits(name, parent) {
  if (!database["$" + parent].isInterface) {
    throw new Error("Inheriting non-interface");
  }
  notFinal["$" + parent] = notFinal["$" + parent] || [];
  notFinal["$" + parent].push(name);

  [].push.apply(database["$" + name].parents, database["$" + parent].parents);
  [].push.apply(database["$" + name].parents, database["$" + parent].members);

  [].push.apply(database["$" + name].tail_parents, database["$" + parent].tail_parents);
  [].push.apply(database["$" + name].tail_parents, database["$" + parent].tail_members);
}
// Step 2. process inheritance
declarations.forEach(function (declaration) {
  switch (declaration.type) {
    case "interface":
      if (declaration.inherit) {
        inherits(declaration.name, declaration.inherit);
      }
      break;
    case "impl":
      if (declaration.parent) {
        inherits(declaration.name, declaration.parent);
      }
      break;
  }
});
var path = require("path");

var content = "\
// Generated by src/" + path.basename(__filename) + ". \n\n\
/**\n\
 * Copyright 2015 Shape Security, Inc.\n\
 *\n\
 * Licensed under the Apache License, Version 2.0 (the \"License\");\n\
 * you may not use this file except in compliance with the License.\n\
 * You may obtain a copy of the License at\n\
 *\n\
 *     http://www.apache.org/licenses/LICENSE-2.0\n\
 *\n\
 * Unless required by applicable law or agreed to in writing, software\n\
 * distributed under the License is distributed on an \"AS IS\" BASIS,\n\
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\
 * See the License for the specific language governing permissions and\n\
 * limitations under the License.\n\
 */\n\
\n\
// Hack to make Babel6 import this as a module.\n\
Object.defineProperty(exports, \"__esModule\", {\n\
  value: true\n\
});\n\
\n\
// Meta data generated from spec.idl.\n\
exports.default = (function() {\n\
  var SPEC = {};\n\
\n\
  var BOOLEAN = { typeName: \"Boolean\" };\n\
  var DOUBLE = { typeName: \"Number\" };\n\
  var STRING = { typeName: \"String\" };\n\
  function Maybe(arg) { return { typeName: \"Maybe\", argument: arg }; }\n\
  function List(arg) { return { typeName: \"List\", argument: arg }; }\n\
  function Const(arg) { return { typeName: \"Const\", argument: arg }; }\n\
  function Union() { return { typeName: \"Union\", arguments: [].slice.call(arguments, 0) }; }\n\
\n";


function renderEnum(declaration) {
  var name = declaration.name;
  return "  var " + declaration.name + " = {\n    typeName: \"Enum\",\n    values: [" + declaration.values.join(", ") + "]\n  };\n\n";
}

content += renderEnum({
  name: TYPE_INDICATOR_ENUM_NAME,
  values: declarations.filter(function(x){ return x.type === "interface"; }).map(function(x){ return "\"" + x.name + "\""; }).sort()
});

declarations.forEach(function (declaration) {
  switch (declaration.type) {
    case "enum":
      content += renderEnum(declaration);
      break;
  }
});

declarations.forEach(function (declaration) {
  switch (declaration.type) {
    case "interface":
      if (!{}.hasOwnProperty.call(notFinal, "$" + declaration.name)) {
        content += "  var " + declaration.name + " = SPEC." + declaration.name + " = {};\n";
      }
      break;
  }
});

content += "\n";

declarations.reverse();
declarations.forEach(function (declaration) {
  if ({}.hasOwnProperty.call(notFinal, "$" + declaration.name)) {
    content += "  var " + declaration.name + " = Union(" + notFinal["$" + declaration.name].join(", ") + ");\n";
  }
});

content += "\n";

function renderInterface(name, members) {
  var result = [];
  if ({}.hasOwnProperty.call(notFinal, "$" + name)) {
    return "";
  } else {
    result.push("  " + name + ".typeName = \"" + name + "\";");

    if (members.length > 0) {
      result.push("  " + name + ".fields = [");
      members.forEach(function (member) {
        if (has(member, "TypeIndicator")) {
          result.push("    { name: \"" + member.member.name.replace(/^_*/, "") + "\", type: Const(" + TYPE_INDICATOR_ENUM_NAME + "), value: \"" + name + "\" },");
        } else {
          result.push("    { name: \"" + member.member.name.replace(/^_*/, "") + "\", type: " + renderType(member.member.t) + " },");
        }
      });
      result.push("  ];");
    } else {
      result.push("  " + name + ".fields = [];");
    }
  }
  result.push("", "");

  return result.join("\n");
}

declarations.reverse();
declarations.forEach(function (declaration) {
  switch (declaration.type) {
    case "interface":
      var def = database["$" + declaration.name];
      content += renderInterface(declaration.name,
        def.parents.concat(def.members).concat(def.tail_parents).concat(def.tail_members));
      break;
  }
});

content += "  return SPEC;\n";
content += "}());\n";

var distDir = __dirname + "/../dist/";

var fs = require("fs");
try { fs.mkdirSync(distDir); } catch (ignored) {}
fs.writeFileSync(distDir + "index.js", content, "utf-8");
