'use strict';

const distDir = __dirname + "/../dist/";
const specPath = require.resolve('shift-spec-idl/spec.idl');
const attributeOrderPath = require.resolve('shift-spec-idl/attribute-order.conf');

const fs = require('fs');
const specConsumer = require('shift-spec-consumer');

const specContents = fs.readFileSync(specPath, 'utf8');
const attributeOrderContents = fs.readFileSync(attributeOrderPath, 'utf8');
const {nodes, enums, namedTypes} = specConsumer(specContents, attributeOrderContents);

function printType(type) {
  switch (type.kind) {
    case 'type':
      return `Const(TYPE_INDICATOR), value: "${type.argument}"`;
    case 'nullable':
      return printType(type.argument) + ' | null | void';
    case 'union':
      return type.argument.map(printType).sort().join(' | ');
    case 'list':
      return `Array<${printType(type.argument)}>`;
    case 'value':
      switch (type.argument) {
        case 'string':
          return 'string';
        case 'double':
          return 'number';
        case 'boolean':
          return 'boolean';
        default:
          throw new Error('Not reached');
      }
    case 'node':
    case 'enum':
    case 'namedType':
      return type.argument;
    default:
      throw new Error('Not reached');
  }
}

function printAttributes(attrs) {
  return attrs.map(attr => {
    return `  ${attr.name}: ${printType(attr.type)},`;
  }).join('\n')
}

function printNode(name, node) {
  let ext = node.parents.length ? ` extends ${node.parents.join(', ')}` : '';
  let attrs = node.attributes.filter(attribute => !attribute.inherited);
  let body = attrs.length ? `\n${printAttributes(attrs)}\n` : '';
  return `interface ${name}${ext} {${body}}`;
}

function printNamedType(name, type) {
  return `type ${name} = ${printType(type)};`;
}

function printEnum(name, values) {
  let body = values.map(value => `  | "${value}"`).join('\n');
  return `type ${name} =\n${body}`;
}

function indent(str) {
  return str.split('\n').map(str => '  ' + str).join('\n');
}

let generatedWarning = '// Generated by src/generate-type-defs.js.';

let copyright = `
/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
`;

let valueType = `type ValueType =
  | { typeName: 'Boolean' }
  | { typeName: 'Number' }
  | { typeName: 'String' }
  | { typeName: 'Enum', values: Array<string> }
  | { typeName: 'Maybe', argument: ValueType }
  | { typeName: 'List', argument: ValueType }
  | { typeName: 'Const', argument: ValueType };`;

let specType = `{
  [key: string]: {
    typeName: string,
    fields: Array<{
      name: string,
      type: ValueType,
      value?: string,
    }>
  },
}`;

function printEnums(enums) {
  return Array.from(enums).map(([name, values]) => {
    return `export ${printEnum(name, values)}`;
  }).join('\n\n');
}

function printNamedTypes(namedTypes) {
  return Array.from(namedTypes).map(([name, type]) => {
    if (name === 'string') return false; // TODO: Bug in shift-spec-consumer exporting "string" named type
    return `export ${printNamedType(name, type)}`;
  }).filter(Boolean).join('\n\n');
}

function printNodes(nodes) {
  return Array.from(nodes).map(([name, node]) => {
    return `export ${printNode(name, node)}`;
  }).join('\n\n');
}

let typeDeclarations = `${printEnums(enums)}

${printNamedTypes(namedTypes)}

${printNodes(nodes)}`;

let flowContent = `${generatedWarning}
// @flow
${copyright}
${typeDeclarations}

${valueType}

declare export default ${specType};
`;

let tsContent = `${generatedWarning}
${copyright}
declare namespace NodeTypes {
${indent(typeDeclarations)}
}

export as namespace NodeTypes;

${valueType}

declare var SPEC: ${specType};

export = SPEC;
`;

try { fs.mkdirSync(distDir); } catch (ignored) {}
fs.writeFileSync(distDir + "index.js.flow", flowContent, "utf-8");
fs.writeFileSync(distDir + "index.d.ts", tsContent, "utf-8");
