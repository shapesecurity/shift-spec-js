'use strict';

const distDir = __dirname + "/../dist/";

const fs = require('fs');

const specConsumer = require('shift-spec-consumer');
const {nodes, enums, namedTypes} = specConsumer(fs.readFileSync(require.resolve('shift-spec-idl/spec.idl'), 'utf8'), fs.readFileSync(require.resolve('shift-spec-idl/attribute-order.conf'), 'utf8'));

function printType(type) {
  switch (type.kind) {
    case 'type':
      return `Const(TYPE_INDICATOR), value: "${type.argument}"`;
    case 'nullable':
      return printType(type.argument) + ' | null | void';
    case 'union':
      return type.argument.map(printType).sort().join(' | ');
    case 'list':
      return `Array<${printType(type.argument)}>`;
    case 'value':
      switch (type.argument) {
        case 'string':
          return 'string';
        case 'double':
          return 'number';
        case 'boolean':
          return 'boolean';
        default:
          throw 'Not reached';
      }
    case 'node':
    case 'enum':
    case 'namedType':
      return type.argument;
    default:
      throw 'Not reached';
  }
}

function printNode(name, node) {
  let res = 'interface ' + name;
  if (node.parents.length) {
    res += ' extends ';
    res += node.parents.join(', ');
  }
  res += ' {';
  let attrs = node.attributes.filter(attribute => {
    return !attribute.inherited;
  });
  if (attrs.length) {
    res += '\n';
    res += attrs.map(attribute => {
      return '  ' + attribute.name + ': ' + printType(attribute.type) + ',\n';
    }).join('');
  }
  res += '}';
  return res;
}

function printNamedType(name, type) {
  return 'type ' + name + ' = ' + printType(type) + ';';
}

function printEnum(name, values) {
  let res = 'type ' + name + ' = ';
  for (let value of values) {
    res += '\n  | "' + value + '"';
  }
  res += ';';
  return res;
}

function indent(str) {
  return str.split('\n').map(str => '  ' + str).join('\n');
}

let copyright = `
/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
`;

let nodeTypes = '';

for (let [name, values] of enums) {
  nodeTypes += '\nexport ' + printEnum(name, values) + '\n';
}

for (let [name, type] of namedTypes) {
  if (name === 'string') continue; // wat
  nodeTypes += 'export ' + printNamedType(name, type) + '\n';
}

for (let [name, node] of nodes) {
  nodeTypes += '\nexport ' + printNode(name, node) + '\n';
}

let flowContent = `// Generated by src/generate-type-defs.js.
// @flow
${copyright}
${nodeTypes}

type ValueType =
  | { typeName: 'Boolean' }
  | { typeName: 'Number' }
  | { typeName: 'String' }
  | { typeName: 'Enum', values: Array<string> }
  | { typeName: 'Maybe', argument: ValueType }
  | { typeName: 'List', argument: ValueType }
  | { typeName: 'Const', argument: ValueType };

declare export default {
  [key: string]: {
    typeName: string,
    fields: Array<{
      name: string,
      type: ValueType,
      value?: string,
    }>
  },
};
`;

let tsContent = `// Generated by src/generate-type-defs.js.
${copyright}
declare namespace NodeTypes {
${indent(nodeTypes)}
}

export as namespace NodeTypes;

type ValueType =
  | { typeName: 'Boolean' }
  | { typeName: 'Number' }
  | { typeName: 'String' }
  | { typeName: 'Enum', values: Array<string> }
  | { typeName: 'Maybe', argument: ValueType }
  | { typeName: 'List', argument: ValueType }
  | { typeName: 'Const', argument: ValueType };

declare var SPEC: {
  [key: string]: {
    typeName: string,
    fields: Array<{
      name: string,
      type: ValueType,
      value?: string,
    }>
  },
};

export = SPEC;
`;

try { fs.mkdirSync(distDir); } catch (ignored) {}
fs.writeFileSync(distDir + "index.js.flow", flowContent, "utf-8");
fs.writeFileSync(distDir + "index.d.ts", tsContent, "utf-8");
